#include<iostream>
#include<algorithm>
#include<string>
#include<vector>
#include<cctype>
#include<random>
#include<thread>
#include<chrono>

using namespace std::string_literals;

//std::find(begin(),end(),to_find)
// many algos call a function on each element which return bool, this is called a predicate
// predicates are passed as callable objects
// sort(begin,end,predicate_func)
//find_if takes a predicate function, find_if_not

// lambda expressions: anonymous local functions
// lambda expressions are first class functor objects that the compiler generates
// used for implementing temporary functions
// systax [](int n)->bool {return n%2 == 1;}
// lambda exp has access to non-local vars(global vars) and static vars
// to capture vars [var_names](int arg){ do something with arg and var_names }
// lambda with capture is implemented as functor with state variable // capture by value and is const
// to make captured variable non const use mutable keyword
// lambda functor is generated by the compiler during compilatrion
// use [&var_name] to capture variable by refrence
// to capture all variables by value [=, &varname]
// to caputure all variables by refrence [&, =varname]
// lambda expression is allowed to capture "this" pointer [this]
// c++14 allows returning of lambda expression from a function
// we can use lambda expr with capture to implement partial evaluation
// c++14 allows auto for the type of argument in lambdas(generic lambdas)
// generic lambda ==> auto func = [](auto x, auto y) {return x + y;};
// for this compiler generates something like a templated functor object
// c++14 also allows creation of local lambda vars like [y=2](auto x) {return x + y;}

// equal(begin(c1), end(c1), begin(c2), end(c2), callable_obj()) ==> compares elements


//  pair type : <utility>
// call auto wordpair{ make_pair(var1, var2)};// to make pair;
// c++17 can deduce type from constructor args

// insert iterators
// if we assign an element to an insert iterator then it will insert an element into the associated container
// to get an insert iterator we need to call one of : back_inserter(container), front_inserter(container), inserter(container, position_iterator)

// function objects provided by std as templated functor objects
// less<type>(), greater<type>(), plus(), minus(), multiplies(), divides(), modulus(),
// equal_to, not_equal_to, greater_equal, less_equal,
// logical_and, logical_or, logical_not, bit_and, bit_or, bit_exor, bit_not(14)


// find_first_of(begin, end, begin(search_container), end(search_container))
//     uses equality operator
// adjacent_find() looks for two neighboring elements with same value
// search_n find n successive elements with same value
// search(begin(), end(), begin(to_search), end(to_search))
// mismatch find first element between two containers which is different: returns pair of iterators
// all_of() returns true if predicate true for every element
// any_of returns true if predicate true for any element
// none_of returns true if predicate false for every element
// binary_search(begin, end, to_search) ==> for sorted elements
// includes(begin, end, begin(to_search), end(to_search)) ==> for sorted element: returns true if every element in to_search exists at least once

// <numeric> : numeric algorithms
// iota() : populates an iterator range with values which successively increase by 1
//		iota(begin(vec), end(vec), first_value)
// accumulate : sum all elements in iterator range and return their sum
//		accumulate(begin(vec), end(vec), initial_sum=0, custom_callable_object)
//		cannot be parallelized
// c++17  => reduce() allows parallel processing with summing

// write_only algo: can write to an iterator range but cannot read, intended for populating containers
// fill(begin(vec), end(vec) , 42) // fill all elements with 42
// auto begin_rest = fill_n(begin(vec), numelements, value) // fills n elements with given value, returns iterator to next element
// generate() uses the returned value from calling a function to assign the elments
//		should return a different value each time it is used
//		generate(begin, end, callable_object_with_state), generate_n(back_inserter(v), 10, square())

// for_each(begin, end, callable_function_object)

// copying algorithm: copy elements into another
// copy(begin, end, begin(dest))
// copy_n also available
// copy_if(begin, end, begin(dest),predicate)

// Write algo : change elements in iterator range
// replace(begin, end, value_to_be_replaced, value_to_replace)
// replace_if(begin, end, predicate)
// replace_copy_if(begin,end, back_inserter, predicate)

// Removing algo
// logically remove the element, physically still present accessing it is undefined behaiour
// remove(begin, end, val) returns iterator to first removed element, uses == operator
// to physically remove use erase(result_of_remove)
// remove_if(begin, end, predicate), remove_copy(begin, end, back_inserter(other), 1)
// remove_copy_if(begin, end, inserter, predicate) copy non removed elements to dest
// unique(begin, end, predicate) removes duplicate adjacent elements (elements should be sorted) similar behaviour to remove                                                                                                                                                                                                                                                                                                                                                                                                             
// unique_copy also avialable: copies unique elements to dest

// transform algo
// call a given function on every element in the range
// transform(begin, end, other_begin, backinserter, func_obj)
// inplace transformation possible (modifying same elements)

// merging algos
// combine two sorted containers into third dest
// merge(begin1, end1, begin2, end2, dest_bacK_inserter)
// set_intersection() write elements that are in both containers
// set_union() no duplicates(both ranges should contain) but all unique elements

// Reordering
// re-arranges the elements inside an iterator range without modifying their values
// reverse(begin(), end()), reverse_copy(begin, end, back_inserter(dest))
// rotate(begin, pivot_iterator, end) : rotate elements around a pivot element
// rotate_copy

// partitioning algo
// partition container into two groups
// partition(begin, end, predicate) ==> will send elements for which predicate is true to the front and rest to back
// stable_partition() keep relative order of the elements
// is_partitioned(begin, end, predicate)
// partition_point ==> returns partition point first element for which predicate is false

// sorting algo
// sort(begin, end, comparator) // quicksort is used, ascending by default and < operator by default
// stable_sort() // same relative order
// is_sorted(begin, end)
// is_sorted_until returns the element till which container is sorted
// partial_sort(begin, begin + element_count, end) // sort first element_count elements
// partial_sort_copy(beginsrc, endsrc, begindest, enddest)
// nth_element performs a partition with the element as the partition point such that before it are all lower and above are greater
// nth_element(begin(vec), position_iterator, end(vec))

// permutation algo: possible arrangement of some elements
// next_permutation(begin, end) // "abc" -> "acb"
// prev_permutation(begin, end) 
// is_permutation(begin, end, begin2, end2) // check if have same elements

// min/max operator can take two args, initializer list or iterator range using < by default
// min(args, preds)
// minmax() ==> returns pair of min and max element iterators

// partial_sum(begin, end, back_inserter(dest)) // running total / cumulative sum
// adjacent_difference(begin, end, back_inserter(dest)) // inverse of partial sum
// inner_product(begin, end, begin2, end2, initial_sum, reduce_operation, transform_operation) 
//     // + and * operator used [a1, b1]*[a2, b2]= a1*a2 + b1*b2
// inner_product can be implemented as combination of transform and accumulate operations
// c++17 has transform_reduce() for parallel processing

// c style random numbers
// rand() Psuedo returns value between 0 and RAND_MAX: <cstdlib> 
// for different ranges 1.0*rand()/RAND_MAX
// to seed the rand: srand(time(0)) // <ctime>
// no standard implimentation, poor cryptographic security, for different range scaling is required which causes bias

// <random>
// default_random_engine eng; // functor.. eng() will give a random number
// distribution takes random_engine as arg
// distribution types : uniform_int_distribution<T>(m, n) ==> makes occurance of all random numbers equally likely in range
// uniform_real_distribution
// random_device to generate true random numbers using entropy data if supported by hardware, not avaialble in g++
// random_device rd; // rd() generates random number
// use rd to create a seed
// marsene twister: mt19937 mt(rd());
// make engine and distribution static as initialization is slow
// shuffle(begin, end, engine) // swap(vec[i], vec[rand_i])
// random_shuffle // deprecated
// bernoulli_distribution bd ==> gives random booleans instead of ints
// to convert reverse iterator to forward use .base()

// \r is carriage return character, it resets the current line to blank

bool check_palindrome(const std::string& s)
{
	auto len = s.length();
	bool ans = false;
	if (len % 2 == 0)
	{
		auto mid = s.cbegin();
		std::advance(mid, (len / 2) + 1);
		ans = std::equal(std::cbegin(s), mid, std::crbegin(s));
	}
	else {
		auto mid = s.cbegin();
		std::advance(mid, (len / 2));
		ans = std::equal(std::cbegin(s), mid, std::crbegin(s));
	}
	return ans;
}

bool check_palindrome_(const std::string& s)
{
	// normalize the string
	std::string temp;

	std::copy_if(std::cbegin(s), std::cend(s), std::back_inserter(temp),
		[](char c) { return isalpha(c); }
	);

	// transform the string
	std::transform(std::begin(temp), std::end(temp), std::begin(temp),
		[](char c) {return tolower(c); });

	// compare the string forward and backwards
	auto res = std::mismatch(std::cbegin(temp), std::cend(temp), std::crbegin(temp));

	if (res.first != temp.end())
	{
		std::cout << *(res.first) << *(res.second) << std::endl;
		return false;
	}

	return true;

}

void random_walk()
{
	std::mt19937 md;
	std::bernoulli_distribution bd;

	int max_pos = 50;
	std::string blank_line{ 50 , ' ' };
	
	int current_pos = 0;

	while (true)
	{
		auto vs = bd(md);
		int vx = vs ? 1 : -1;

		if (current_pos == max_pos) vx = -1;
		if (current_pos == 0) vx = 1;
		current_pos = current_pos + vx;

		std::string lead_spaces, trail_spaces;
		for (int i = 0; i < current_pos; i++) lead_spaces += ' ';
		for (int i = current_pos + 1; i < max_pos; i++) trail_spaces += ' ';
		std::cout << '\r' << blank_line;
		std::cout << '\r' << lead_spaces << '*' << trail_spaces ;
		std::this_thread::sleep_for(std::chrono::milliseconds(100));
	}

}

void sort_and_print(std::vector<int>& v)
{
	std::sort(v.begin(), v.end(), [](int a, int b) {return a > b; });
	for (int i : v)
	{
		std::cout << i << ",";
	} std::cout << std::endl;
}

int main_algoover()
{
	//random_walk();
	
	std::string palin{ "alaala" };
	std::string palin_odd{ "abcba" };
	std::cout << std::boolalpha << palin << ": " << check_palindrome(palin) << std::endl;
	std::cout << palin_odd << ": " << check_palindrome(palin_odd) << std::endl;
	std::cout << "hahahaa : " << check_palindrome("hahahaa"s) << std::endl;
	
	std::istream_iterator<std::string> iis{std::cin};
	std::istream_iterator<std::string> eof;

	std::vector<std::string> strvec;
	auto it = std::back_inserter(strvec);

	while (iis != eof)
	{
		*it = *iis;
		++iis;
	}

	std::ostream_iterator<std::string> oss{ std::cout };

	for (auto& s : strvec)
	{
		*oss = s + " "s;
	}
	*oss = "\n";
	/*int y = 1;

	auto func = [y = y + 1](int x) {return x + y; };
	std::cout << func(5) << std::endl;
	std::cout << y << std::endl;*/
	
	/*int x{ 42 }, y{ 99 }, z{ 0 };

	auto lam = [=, &z]() mutable { ++x; ++y; z = x + y; };
	lam();
	std::cout << x << " " << y << " " << z << std::endl;
	lam();
	std::cout << x << " " << y << " " << z << std::endl;*/



	/*std::vector<int> v{ 1,2,3,4,5 };
	sort_and_print(v);*/

	/*std::string test{ "hahahahll" };
	auto it = std::find(std::begin(test), std::end(test), 'l');
	if(it != test.end())
		std::cout << std::distance(std::begin(test), it) << std::endl;
	auto it2 = std::find_if(std::begin(test), std::end(test), [](char c) {return c < 'c'; });
	if (it2 != test.end())
		std::cout << std::distance(std::begin(test), it2) << std::endl;*/
	return 0;
}